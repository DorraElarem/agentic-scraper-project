#!/usr/bin/env python3
"""
üß™ TEST COMPLET POUR IDENTIFIER L'ERREUR INT('0/1')
==================================================
Ce script teste tous les composants individuellement pour identifier pr√©cis√©ment
o√π l'erreur se produit dans votre cha√Æne d'ex√©cution.
"""

import sys
import os
import traceback
import logging
from datetime import datetime

# Configuration du logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def test_imports():
    """Teste les imports un par un pour identifier les erreurs"""
    print("üß™ TEST DES IMPORTS")
    print("=" * 50)
    
    tests = [
        ("os", lambda: __import__('os')),
        ("sys", lambda: __import__('sys')),
        ("uuid", lambda: __import__('uuid')),
        ("datetime", lambda: __import__('datetime')),
        ("logging", lambda: __import__('logging')),
        ("fastapi", lambda: __import__('fastapi')),
        ("sqlalchemy.orm", lambda: __import__('sqlalchemy.orm')),
        ("app.utils.helpers", lambda: __import__('app.utils.helpers')),
        ("app.models.database", lambda: __import__('app.models.database')),
        ("app.models.schemas", lambda: __import__('app.models.schemas')),
        ("app.tasks.scraping_tasks", lambda: __import__('app.tasks.scraping_tasks')),
    ]
    
    for name, import_func in tests:
        try:
            import_func()
            print(f"‚úÖ {name}: OK")
        except Exception as e:
            print(f"‚ùå {name}: ERREUR - {str(e)}")
            traceback.print_exc()

def test_helper_functions():
    """Teste les fonctions helper individuellement"""
    print("\nüß™ TEST DES FONCTIONS HELPER")
    print("=" * 50)
    
    try:
        from app.utils.helpers import safe_parse_progress, validate_progress_pair, normalize_progress_string
        
        # Test 1: safe_parse_progress
        test_cases = [
            ("0", 0),
            ("5", 5), 
            ("0/1", 0),
            ("3/5", 3),
            ("10.5", 10),
            ("invalid", 0),
            (None, 0),
            (42, 42),
            ("  7.8  ", 7)
        ]
        
        print("üîç Test safe_parse_progress:")
        for value, expected in test_cases:
            try:
                result = safe_parse_progress(value)
                status = "‚úÖ" if result == expected else "‚ö†Ô∏è"
                print(f"   {status} safe_parse_progress({repr(value)}) = {result} (attendu: {expected})")
            except Exception as e:
                print(f"   ‚ùå safe_parse_progress({repr(value)}) = ERREUR: {e}")
        
        # Test 2: validate_progress_pair
        print("\nüîç Test validate_progress_pair:")
        pair_tests = [
            ((0, 1), (0, 1)),
            (("0", "5"), (0, 5)),
            (("3/5", "10"), (3, 10)),
            ((None, None), (0, 1)),
        ]
        
        for (current, total), (exp_current, exp_total) in pair_tests:
            try:
                result_current, result_total = validate_progress_pair(current, total)
                status = "‚úÖ" if (result_current == exp_current and result_total == exp_total) else "‚ö†Ô∏è"
                print(f"   {status} validate_progress_pair({repr(current)}, {repr(total)}) = ({result_current}, {result_total})")
            except Exception as e:
                print(f"   ‚ùå validate_progress_pair({repr(current)}, {repr(total)}) = ERREUR: {e}")
        
        # Test 3: normalize_progress_string
        print("\nüîç Test normalize_progress_string:")
        norm_tests = ["0", "5", "3/5", 10, None, "invalid"]
        for value in norm_tests:
            try:
                result = normalize_progress_string(value)
                print(f"   ‚úÖ normalize_progress_string({repr(value)}) = '{result}'")
            except Exception as e:
                print(f"   ‚ùå normalize_progress_string({repr(value)}) = ERREUR: {e}")
                
    except Exception as e:
        print(f"‚ùå Impossible d'importer les helpers: {e}")
        traceback.print_exc()

def test_database_models():
    """Teste les mod√®les de base de donn√©es"""
    print("\nüß™ TEST DES MOD√àLES DATABASE")
    print("=" * 50)
    
    try:
        from app.models.database import ScrapingTask, get_db
        
        # Test creation d'un objet ScrapingTask
        print("üîç Test cr√©ation ScrapingTask:")
        task = ScrapingTask(
            task_id="test-123",
            urls=["https://example.com"],
            status="pending",
            progress_current="0",
            progress_total="1"
        )
        
        print(f"‚úÖ Cr√©ation task OK")
        print(f"   task_id: {task.task_id}")
        print(f"   progress_current: {task.progress_current} ({type(task.progress_current)})")
        print(f"   progress_total: {task.progress_total} ({type(task.progress_total)})")
        
        # Test des m√©thodes
        print("\nüîç Test m√©thodes ScrapingTask:")
        
        try:
            display = task.progress_display
            print(f"‚úÖ progress_display: '{display}'")
        except Exception as e:
            print(f"‚ùå progress_display: ERREUR - {e}")
            traceback.print_exc()
            
        try:
            progress_dict = task.get_progress_dict()
            print(f"‚úÖ get_progress_dict: {progress_dict}")
        except Exception as e:
            print(f"‚ùå get_progress_dict: ERREUR - {e}")
            traceback.print_exc()
            
        try:
            success = task.set_progress("2", "5")
            print(f"‚úÖ set_progress('2', '5'): {success}")
            print(f"   Nouveau current: {task.progress_current}")
            print(f"   Nouveau total: {task.progress_total}")
        except Exception as e:
            print(f"‚ùå set_progress: ERREUR - {e}")
            traceback.print_exc()
            
    except Exception as e:
        print(f"‚ùå Erreur test mod√®les: {e}")
        traceback.print_exc()

def test_schemas():
    """Teste les sch√©mas Pydantic"""
    print("\nüß™ TEST DES SCH√âMAS PYDANTIC")
    print("=" * 50)
    
    try:
        from app.models.schemas import ProgressDetail, ScrapingTaskRequest, AnalysisType
        
        # Test ProgressDetail
        print("üîç Test ProgressDetail:")
        test_cases = [
            {"current": 0, "total": 1},
            {"current": "3", "total": "5"},
            {"current": "3/10", "total": "20"},
        ]
        
        for i, case in enumerate(test_cases):
            try:
                progress = ProgressDetail(**case)
                print(f"‚úÖ Test {i+1}: current={progress.current}, total={progress.total}, display='{progress.display}'")
            except Exception as e:
                print(f"‚ùå Test {i+1}: ERREUR - {e}")
                traceback.print_exc()
        
        # Test ScrapingTaskRequest
        print("\nüîç Test ScrapingTaskRequest:")
        try:
            request = ScrapingTaskRequest(
                urls=["https://example.com"],
                analysis_type=AnalysisType.STANDARD
            )
            print(f"‚úÖ ScrapingTaskRequest cr√©√©: {request.urls}, {request.analysis_type}")
        except Exception as e:
            print(f"‚ùå ScrapingTaskRequest: ERREUR - {e}")
            traceback.print_exc()
            
    except Exception as e:
        print(f"‚ùå Erreur test sch√©mas: {e}")
        traceback.print_exc()

def test_celery_import():
    """Teste l'import de la t√¢che Celery"""
    print("\nüß™ TEST IMPORT CELERY TASK")
    print("=" * 50)
    
    try:
        from app.tasks.scraping_tasks import enqueue_scraping_task
        print(f"‚úÖ Import enqueue_scraping_task: OK")
        
        # Affichage des infos de la t√¢che
        print(f"   Nom: {enqueue_scraping_task.name}")
        print(f"   Bind: {getattr(enqueue_scraping_task, 'bind', 'N/A')}")
        
        # V√©rifier si apply_async est disponible
        if hasattr(enqueue_scraping_task, 'apply_async'):
            print(f"‚úÖ apply_async disponible")
        else:
            print(f"‚ùå apply_async indisponible")
            
        # V√©rifier si apply est disponible  
        if hasattr(enqueue_scraping_task, 'apply'):
            print(f"‚úÖ apply disponible")
        else:
            print(f"‚ùå apply indisponible")
            
    except Exception as e:
        print(f"‚ùå Erreur import Celery task: {e}")
        traceback.print_exc()

def test_worker_connection():
    """Teste la connexion au worker Celery"""
    print("\nüß™ TEST CONNEXION WORKER")
    print("=" * 50)
    
    try:
        from app.worker import celery
        print("‚úÖ Celery app trouv√©e")
        
        # V√©rifier la configuration
        print(f"   Backend: {celery.conf.result_backend}")
        print(f"   Broker: {celery.conf.broker_url}")
        print(f"   Always Eager: {celery.conf.task_always_eager}")
        
        # Test basic du worker avec gestion d'erreur Redis
        try:
            inspect_result = celery.control.inspect()
            stats = inspect_result.stats()
            if stats:
                print(f"‚úÖ Worker connect√©: {list(stats.keys())}")
            else:
                print("‚ùå Aucun worker actif d√©tect√©")
        except Exception as redis_error:
            print(f"‚ùå Erreur connexion Redis/Worker: {str(redis_error)[:200]}...")
            if "getaddrinfo failed" in str(redis_error):
                print("üí° Solution: Configurez CELERY_ALWAYS_EAGER=True dans .env pour le d√©veloppement")
                
    except Exception as e:
        print(f"‚ùå Erreur test worker: {e}")
        traceback.print_exc()

def test_celery_task_creation():
    """Teste la cr√©ation de t√¢che Celery en mode simulation"""
    print("\nüß™ TEST SIMULATION CELERY TASK")
    print("=" * 50)
    
    try:
        # Simuler les √©tapes de cr√©ation sans Celery r√©el
        from app.models.database import ScrapingTask
        from app.utils.helpers import validate_progress_pair, normalize_progress_string
        import uuid
        
        print("üîç Simulation cr√©ation t√¢che:")
        
        # √âtape 1: G√©n√©ration ID
        task_id = str(uuid.uuid4())
        print(f"‚úÖ ID g√©n√©r√©: {task_id}")
        
        # √âtape 2: Validation URLs
        urls = ["https://www.ins.tn/statistiques"]
        total_urls = len(urls)
        print(f"‚úÖ URLs valid√©es: {total_urls} URLs")
        
        # √âtape 3: Normalisation progression - ICI PEUT √äTRE L'ERREUR
        try:
            safe_current, safe_total = validate_progress_pair(0, total_urls)
            print(f"‚úÖ Progression normalis√©e: current={safe_current}, total={safe_total}")
            
            normalized_current = normalize_progress_string(safe_current)
            normalized_total = normalize_progress_string(safe_total)
            print(f"‚úÖ Strings normalis√©es: current='{normalized_current}', total='{normalized_total}'")
            
        except Exception as e:
            print(f"‚ùå ERREUR lors de la normalisation: {e}")
            if "invalid literal for int()" in str(e) and "0/1" in str(e):
                print("üéØ ERREUR INT('0/1') TROUV√âE ICI!")
            traceback.print_exc()
            return
        
        # √âtape 4: Cr√©ation objet (sans DB)
        try:
            db_task = ScrapingTask(
                task_id=task_id,
                urls=urls,
                status="pending",
                progress_current=normalized_current,
                progress_total=normalized_total,
                analysis_type="standard",
                parameters={},
                priority=1,
                created_at=datetime.utcnow()
            )
            print(f"‚úÖ Objet ScrapingTask cr√©√©")
            print(f"   progress_current: '{db_task.progress_current}' ({type(db_task.progress_current)})")
            print(f"   progress_total: '{db_task.progress_total}' ({type(db_task.progress_total)})")
            
            # Test des m√©thodes sur l'objet cr√©√©
            display = db_task.progress_display
            print(f"‚úÖ progress_display: '{display}'")
            
            progress_dict = db_task.get_progress_dict()
            print(f"‚úÖ get_progress_dict: {progress_dict}")
            
        except Exception as e:
            print(f"‚ùå ERREUR cr√©ation objet ScrapingTask: {e}")
            if "invalid literal for int()" in str(e):
                print("üéØ ERREUR INT() TROUV√âE DANS LA CR√âATION D'OBJET!")
            traceback.print_exc()
            return
            
        print("\nüéØ SIMULATION R√âUSSIE - L'erreur ne vient PAS de la logique de cr√©ation")
        
    except Exception as e:
        print(f"‚ùå Erreur test simulation: {e}")
        traceback.print_exc()

def test_edge_cases():
    """Teste les cas limites qui peuvent causer int('0/1')"""
    print("\nüß™ TEST CAS LIMITES INT('0/1')")
    print("=" * 50)
    
    # Test direct des conversions dangereuses
    dangerous_values = ["0/1", "3/5", "10/20", "abc/def", "0.5/1", ""]
    
    print("üîç Test conversions directes (pour reproduire l'erreur):")
    for value in dangerous_values:
        try:
            result = int(value)
            print(f"   ‚ö†Ô∏è  int('{value}') = {result} (inattendu!)")
        except ValueError as e:
            if "0/1" in value:
                print(f"   üéØ int('{value}') = ERREUR REPRODUITE: {e}")
            else:
                print(f"   ‚úÖ int('{value}') = erreur attendue: {e}")
    
    # Test avec safe_parse_progress
    print("\nüîç Test avec safe_parse_progress (devrait fonctionner):")
    try:
        from app.utils.helpers import safe_parse_progress
        for value in dangerous_values:
            try:
                result = safe_parse_progress(value)
                print(f"   ‚úÖ safe_parse_progress('{value}') = {result}")
            except Exception as e:
                print(f"   ‚ùå safe_parse_progress('{value}') = ERREUR: {e}")
    except ImportError:
        print("   ‚ùå Impossible d'importer safe_parse_progress")

def test_reproduce_int_error():
    """Test sp√©cifique pour reproduire et localiser l'erreur int('0/1')"""
    print("\nüß™ TEST REPRODUCTION ERREUR INT('0/1')")
    print("=" * 50)
    
    # Test direct de l'erreur
    try:
        result = int("0/1")
        print(f"‚ö†Ô∏è  int('0/1') = {result} (ne devrait pas arriver!)")
    except ValueError as e:
        print(f"‚úÖ int('0/1') reproduit l'erreur: {e}")
    
    # Test avec nos fonctions s√©curis√©es
    try:
        from app.utils.helpers import safe_parse_progress, normalize_progress_string
        
        safe_result = safe_parse_progress("0/1", 0)
        normalized = normalize_progress_string("0/1")
        
        print(f"‚úÖ safe_parse_progress('0/1') = {safe_result}")
        print(f"‚úÖ normalize_progress_string('0/1') = '{normalized}'")
        
        print("\nüí° CONCLUSION:")
        print("   Si votre code utilise int('0/1') quelque part,")
        print("   remplacez par safe_parse_progress('0/1')")
        
    except ImportError as e:
        print(f"‚ùå Impossible d'importer helpers: {e}")

def test_manual_task_execution():
    """Teste l'ex√©cution manuelle de la t√¢che avec la BONNE signature"""
    print("\nüß™ TEST EX√âCUTION MANUELLE CELERY")
    print("=" * 50)
    
    try:
        from app.tasks.scraping_tasks import enqueue_scraping_task
        from app.models.schemas import AnalysisType
        
        # Param√®tres pour le test
        test_params = {
            'task_id': 'test-manual-123',
            'urls': ['https://www.ins.tn/statistiques'],
            'analysis_type': AnalysisType.STANDARD,
            'callback_url': None,
            'parameters': {},
            'priority': 1
        }
        
        print(f"üîç Test avec param√®tres: {test_params}")
        
        # ‚úÖ M√âTHODE 1: Test avec .apply() (mode synchrone)
        print("\nüîç M√©thode 1: Celery .apply() synchrone")
        try:
            result = enqueue_scraping_task.apply(
                args=[
                    test_params['task_id'],       # task_id
                    test_params['urls'],          # urls
                    test_params['analysis_type'], # analysis_type
                    test_params['callback_url'],  # callback_url
                    test_params['parameters'],    # parameters
                    test_params['priority']       # priority
                ]
            )
            print(f"‚úÖ .apply() r√©ussi!")
            print(f"   √âtat: {result.state}")
            print(f"   R√©sultat: {str(result.result)[:200]}...")
            
        except Exception as apply_error:
            print(f"‚ùå .apply() √©chou√©: {apply_error}")
            
            # D√©tecter l'erreur int('0/1')
            error_str = str(apply_error)
            if "invalid literal for int()" in error_str:
                print("üö® ERREUR INT() TROUV√âE AVEC .apply()!")
                if "0/1" in error_str:
                    print("üéØ BINGO! ERREUR INT('0/1') TROUV√âE!")
                    print("üìç Stack trace compl√®te:")
                    traceback.print_exc()
                    return
                    
        # ‚úÖ M√âTHODE 2: Test avec signature minimale si erreur de param√®tres
        print("\nüîç M√©thode 2: Signature minimale (task_id, urls, analysis_type)")
        try:
            result = enqueue_scraping_task.apply(
                args=[
                    test_params['task_id'],
                    test_params['urls'],
                    test_params['analysis_type']
                ]
            )
            print(f"‚úÖ Signature minimale r√©ussie!")
            print(f"   √âtat: {result.state}")
            
        except Exception as min_error:
            print(f"‚ùå Signature minimale √©chou√©e: {min_error}")
            
            # D√©tecter l'erreur int('0/1')
            error_str = str(min_error)
            if "invalid literal for int()" in error_str:
                print("üö® ERREUR INT() TROUV√âE AVEC SIGNATURE MINIMALE!")
                if "0/1" in error_str:
                    print("üéØ BINGO! ERREUR INT('0/1') TROUV√âE!")
                    print("üìç Stack trace compl√®te:")
                    traceback.print_exc()
                    return
        
        # ‚úÖ M√âTHODE 3: Test avec appel direct (bypass Celery)
        print("\nüîç M√©thode 3: Appel direct de fonction (bypass Celery)")
        try:
            # Cr√©er un mock self simple
            class MockCeleryTask:
                def __init__(self):
                    self.request = type('MockRequest', (), {
                        'id': 'test-request-id', 
                        'retries': 0
                    })()
                    self.max_retries = 3
                    
                def update_state(self, state, meta=None):
                    print(f"   üìä Mock Celery state: {state}")
                    
                def retry(self, exc=None, countdown=None):
                    print(f"   üîÑ Mock retry: countdown={countdown}")
                    raise exc
            
            mock_self = MockCeleryTask()
            
            # Appel direct avec mock self
            result = enqueue_scraping_task(
                mock_self,
                test_params['task_id'],
                test_params['urls'],
                test_params['analysis_type'],
                test_params['callback_url'],
                test_params['parameters'],
                test_params['priority']
            )
            
            print(f"‚úÖ Appel direct r√©ussi!")
            print(f"   Type r√©sultat: {type(result)}")
            print(f"   Contenu: {str(result)[:200]}...")
            
        except Exception as direct_error:
            print(f"‚ùå Appel direct √©chou√©: {direct_error}")
            print(f"   Type d'erreur: {type(direct_error).__name__}")
            
            # D√©tecter l'erreur int('0/1')
            error_str = str(direct_error)
            if "invalid literal for int()" in error_str:
                print("üö® ERREUR INT() TROUV√âE AVEC APPEL DIRECT!")
                
                if "0/1" in error_str:
                    print("üéØ BINGO! ERREUR INT('0/1') TROUV√âE DANS LA FONCTION!")
                elif "/" in error_str:
                    print(f"üéØ ERREUR INT() avec slash: {error_str}")
                
                print("üìç Stack trace compl√®te:")
                traceback.print_exc()
                
                # Analyser la stack trace pour localiser l'erreur
                print("\nüîç ANALYSE DE LA STACK TRACE:")
                exc_type, exc_value, exc_traceback = sys.exc_info()
                if exc_traceback:
                    for frame_info in traceback.extract_tb(exc_traceback):
                        if "int(" in frame_info.line or "0/1" in frame_info.line:
                            print(f"üéØ LIGNE PROBL√âMATIQUE TROUV√âE:")
                            print(f"   Fichier: {frame_info.filename}")
                            print(f"   Ligne {frame_info.lineno}: {frame_info.line}")
                            
            elif "getaddrinfo failed" in error_str:
                print("‚ÑπÔ∏è  Erreur de connexion Redis (normal)")
                print("üí° Configurez CELERY_ALWAYS_EAGER=True dans .env")
            elif "database" in error_str.lower() or "connection" in error_str.lower():
                print("‚ÑπÔ∏è  Erreur de base de donn√©es (normal sans DB)")
            else:
                print(f"‚ÑπÔ∏è  Autre erreur: {error_str[:300]}...")
                
    except ImportError as import_error:
        print(f"‚ùå Erreur import: {import_error}")
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale test manuel: {e}")
        traceback.print_exc()

def test_check_helpers_usage():
    """V√©rifie que les helpers sont bien utilis√©s partout"""
    print("\nüß™ TEST V√âRIFICATION USAGE HELPERS")
    print("=" * 50)
    
    try:
        import inspect
        from app.tasks import scraping_tasks
        
        # R√©cup√©rer le code source du module
        source_code = inspect.getsource(scraping_tasks)
        
        # Chercher les usages dangereux de int()
        lines = source_code.split('\n')
        dangerous_patterns = ['int(', 'int (']
        
        print("üîç Recherche d'usages dangereux de int():")
        found_dangerous = False
        
        for i, line in enumerate(lines, 1):
            for pattern in dangerous_patterns:
                if pattern in line and 'safe_parse_progress' not in line:
                    print(f"‚ö†Ô∏è  Ligne {i}: {line.strip()}")
                    found_dangerous = True
        
        if not found_dangerous:
            print("‚úÖ Aucun usage dangereux de int() d√©tect√©")
        else:
            print("‚ùå Usages dangereux de int() trouv√©s - remplacez par safe_parse_progress()")
            
        # V√©rifier les usages de safe_parse_progress
        safe_usage_count = source_code.count('safe_parse_progress')
        print(f"‚úÖ Usages de safe_parse_progress: {safe_usage_count}")
        
    except Exception as e:
        print(f"‚ùå Erreur v√©rification helpers: {e}")

def main():
    print("üöÄ TEST COMPLET POUR IDENTIFIER L'ERREUR INT('0/1')")
    print("=" * 80)
    print("Ce test va identifier pr√©cis√©ment o√π l'erreur se produit")
    print("=" * 80)
    
    # Tests en s√©quence logique
    test_imports()
    test_helper_functions()
    test_database_models()
    test_schemas()
    test_celery_import()
    test_worker_connection()
    test_celery_task_creation()
    test_edge_cases()
    test_reproduce_int_error()
    test_check_helpers_usage()  # ‚úÖ NOUVEAU: V√©rifier l'usage des helpers
    test_manual_task_execution() # Test final avec toutes les m√©thodes
    
    print("\nüéØ ANALYSE TERMIN√âE")
    print("=" * 80)
    print("Regardez les r√©sultats ci-dessus pour identifier o√π l'erreur se produit.")
    print("Si 'BINGO! ERREUR INT('0/1') TROUV√âE!' appara√Æt, nous avons trouv√© la source!")
    
    print("\nüí° INSTRUCTIONS DE R√âSOLUTION:")
    print("1. Si erreur Redis: Ajoutez CELERY_ALWAYS_EAGER=True dans .env")
    print("2. Si erreur int('0/1'): Remplacez int() par safe_parse_progress()")
    print("3. Si erreur signature: Utilisez .apply() avec 6 arguments")
    print("4. Si erreur DB: Normal sans base de donn√©es connect√©e")

if __name__ == "__main__":
    main()